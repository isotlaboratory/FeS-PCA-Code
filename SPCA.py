import numpy as np
import scipy as sp
from sklearn.metrics.pairwise import pairwise_kernels

class SPCA:
    
    def __init__(self, n_components=None, X_kernel=None, X_kernel_args={}, Y_kernel=None, Y_kernel_args={}, dual=False, K_centroids=50, eps=1e-10):
        """
            n_components(int): The number of principal components to use for projection.
            X_kernel(str): The kernel used to generate the data kernel matrix used in Kernel Supervised PCA, generated by sklearn.metrics.pairwise.
            X_kernel_args(dictionary): Arguments passed to kernel function specified by X_kernel.
            Y_kernel(str): The kernel used to generate the label kernel matrix, generated by sklearn.metrics.pairwise.
            Y_kernel_args(dictionary): Arguments passed to kernel function specified by Y_kernel.
            dual(boolean): Weather to use the dual formulation of SPCA (ignored if X_kernel != None).
            eps(float): Very small number added to the diagonal of L in dual SPCA or K in Kernel SPCA for numerical stability
        """

        self.n_components_ = n_components
        self.X_kernel = X_kernel
        self.X_kernel_args = X_kernel_args
        self.Y_kernel = Y_kernel
        self.Y_kernel_args = Y_kernel_args
        self.dual = dual
        self.eps = eps

    def fit(self, Xs, Ys):
        """
        Xs(list of numpy arrays): each clients nxm feature matrix.
        Ys(list of numpy arrays): each clients corresponding label vector, if concatenated along axis 0, result should be nxc.
        """

        n = sum([cur_X.shape[0] for cur_X in Xs])
        m = Xs[0].shape[1]
        c = Ys[0].shape[1]

        # compute centring matrix
        e = np.ones((n,1))
        I = np.identity(n)
        H = I - (1/n) * np.dot(e,e.T)

        # concatenate clients data
        X = np.concatenate(Xs,axis=0).T
        Y = np.concatenate(Ys,axis=0)

        # compute label kernel matrix
        if self.Y_kernel == 'rbf':
            L = pairwise_kernels(Y, metric=self.Y_kernel, **self.Y_kernel_args)
        else:
            L = Y.dot(Y.T)

        if self.dual == True: # dual SPCA
            
            # compute XHDelta
            L = L+(np.identity(L.shape[0]))
            Delta = np.linalg.cholesky(L)
            psi = X.dot(H).dot(Delta)

            # determine index of top principal components
            m = X[0].shape[0]
            if self.n_components_ != None:
                indexes=[m-self.n_components_, m-1]
            else: 
                indexes=None

            #U, the eigenvectors, correspond to V from Section 5.2 of Barshan et al.
            V, U = sp.linalg.eigh((psi.T).dot(psi), subset_by_index=indexes)

            #V, the eigenvalues, used to create Sigma from Section 5.2 of Barshan et al.
            Sigma = np.sqrt(V*np.identity(V.shape[0]))
            Sigma_inv = np.linalg.inv(Sigma)

            U = psi.dot(U).dot(Sigma_inv)
            
            self.eigenvectors_ = U #eigen vectors
            self.eigenvalues_ = V #eigen values

        elif self.X_kernel == None:

            # compute XHLHX
            Q = X.dot(H).dot(L+np.identity(L.shape[0])).dot(H).dot(X.T)
            
            # determine index of top principal components
            m = Xs[0].shape[1]
            if self.n_components_ != None:
                indexes=[m-self.n_components_, m-1]
            else: 
                indexes=None
            
            # compute supervised principal components
            V, U = sp.linalg.eigh(Q, subset_by_index=indexes)
            
            self.eigenvectors_ = U #eigen vectors
            self.eigenvalues_ = V #eigen valuess
            
        else:

            # obtain kernel matrix from X
            K = pairwise_kernels(X.T, metric=self.X_kernel, **self.X_kernel_args)


            # determine index of top principal components
            if self.n_components_ != None:
                indexes=[ n-self.n_components_, n-1]
            else: 
                indexes=None

            # server computes supervised principal components
            Q = K.dot(H).dot(L+(np.identity(L.shape[0]))).dot(H).dot(K)
            K = K + (self.eps*np.identity(K.shape[0]))

            #U, the eigenvectors, corresponds to Î² in Section 5.3.2 of Barshan et al. 
            V, U = sp.linalg.eigh(Q, b=K, subset_by_index=indexes)
            
            self.eigenvectors_ = U #eigen vectors
            self.eigenvalues_ = V #eigen values

        return